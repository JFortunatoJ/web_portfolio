{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { PLATFORM_ID, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, Input, Output, ViewChild, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, BehaviorSubject, of, combineLatest, pipe, Observable, fromEventPattern, merge } from 'rxjs';\nimport { take, startWith, combineLatest as combineLatest$1, skipWhile, map, scan, distinctUntilChanged, tap, mergeMap, takeUntil, publish, switchMap, withLatestFrom, filter } from 'rxjs/operators'; /// <reference types=\"youtube\" />\n\nconst _c0 = [\"youtubeContainer\"];\nconst DEFAULT_PLAYER_WIDTH = 640;\nconst DEFAULT_PLAYER_HEIGHT = 390;\n/**\n * Angular component that renders a YouTube player via the YouTube player\n * iframe API.\n * @see https://developers.google.com/youtube/iframe_api_reference\n */\n\nlet YouTubePlayer = /*#__PURE__*/(() => {\n  class YouTubePlayer {\n    constructor(_ngZone, platformId) {\n      this._ngZone = _ngZone;\n      this._youtubeContainer = new Subject();\n      this._destroyed = new Subject();\n      this._playerChanges = new BehaviorSubject(undefined);\n      this._videoId = new BehaviorSubject(undefined);\n      this._height = new BehaviorSubject(DEFAULT_PLAYER_HEIGHT);\n      this._width = new BehaviorSubject(DEFAULT_PLAYER_WIDTH);\n      this._startSeconds = new BehaviorSubject(undefined);\n      this._endSeconds = new BehaviorSubject(undefined);\n      this._suggestedQuality = new BehaviorSubject(undefined);\n      this._playerVars = new BehaviorSubject(undefined);\n      /** Outputs are direct proxies from the player itself. */\n\n      this.ready = this._getLazyEmitter('onReady');\n      this.stateChange = this._getLazyEmitter('onStateChange');\n      this.error = this._getLazyEmitter('onError');\n      this.apiChange = this._getLazyEmitter('onApiChange');\n      this.playbackQualityChange = this._getLazyEmitter('onPlaybackQualityChange');\n      this.playbackRateChange = this._getLazyEmitter('onPlaybackRateChange');\n      this._isBrowser = isPlatformBrowser(platformId);\n    }\n    /** YouTube Video ID to view */\n\n\n    get videoId() {\n      return this._videoId.value;\n    }\n\n    set videoId(videoId) {\n      this._videoId.next(videoId);\n    }\n    /** Height of video player */\n\n\n    get height() {\n      return this._height.value;\n    }\n\n    set height(height) {\n      this._height.next(height || DEFAULT_PLAYER_HEIGHT);\n    }\n    /** Width of video player */\n\n\n    get width() {\n      return this._width.value;\n    }\n\n    set width(width) {\n      this._width.next(width || DEFAULT_PLAYER_WIDTH);\n    }\n    /** The moment when the player is supposed to start playing */\n\n\n    set startSeconds(startSeconds) {\n      this._startSeconds.next(startSeconds);\n    }\n    /** The moment when the player is supposed to stop playing */\n\n\n    set endSeconds(endSeconds) {\n      this._endSeconds.next(endSeconds);\n    }\n    /** The suggested quality of the player */\n\n\n    set suggestedQuality(suggestedQuality) {\n      this._suggestedQuality.next(suggestedQuality);\n    }\n    /**\n     * Extra parameters used to configure the player. See:\n     * https://developers.google.com/youtube/player_parameters.html?playerVersion=HTML5#Parameters\n     */\n\n\n    get playerVars() {\n      return this._playerVars.value;\n    }\n\n    set playerVars(playerVars) {\n      this._playerVars.next(playerVars);\n    }\n\n    ngOnInit() {\n      // Don't do anything if we're not in a browser environment.\n      if (!this._isBrowser) {\n        return;\n      }\n\n      let iframeApiAvailableObs = of(true);\n\n      if (!window.YT || !window.YT.Player) {\n        if (this.showBeforeIframeApiLoads && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throw new Error('Namespace YT not found, cannot construct embedded youtube player. ' + 'Please install the YouTube Player API Reference for iframe Embeds: ' + 'https://developers.google.com/youtube/iframe_api_reference');\n        }\n\n        const iframeApiAvailableSubject = new Subject();\n        this._existingApiReadyCallback = window.onYouTubeIframeAPIReady;\n\n        window.onYouTubeIframeAPIReady = () => {\n          if (this._existingApiReadyCallback) {\n            this._existingApiReadyCallback();\n          }\n\n          this._ngZone.run(() => iframeApiAvailableSubject.next(true));\n        };\n\n        iframeApiAvailableObs = iframeApiAvailableSubject.pipe(take(1), startWith(false));\n      } // An observable of the currently loaded player.\n\n\n      const playerObs = createPlayerObservable(this._youtubeContainer, this._videoId, iframeApiAvailableObs, this._width, this._height, this._playerVars, this._ngZone).pipe(tap(player => {\n        // Emit this before the `waitUntilReady` call so that we can bind to\n        // events that happen as the player is being initialized (e.g. `onReady`).\n        this._playerChanges.next(player);\n      }), waitUntilReady(player => {\n        // Destroy the player if loading was aborted so that we don't end up leaking memory.\n        if (!playerIsReady(player)) {\n          player.destroy();\n        }\n      }), takeUntil(this._destroyed), publish()); // Set up side effects to bind inputs to the player.\n\n      playerObs.subscribe(player => {\n        this._player = player;\n\n        if (player && this._pendingPlayerState) {\n          this._initializePlayer(player, this._pendingPlayerState);\n        }\n\n        this._pendingPlayerState = undefined;\n      });\n      bindSizeToPlayer(playerObs, this._width, this._height);\n      bindSuggestedQualityToPlayer(playerObs, this._suggestedQuality);\n      bindCueVideoCall(playerObs, this._videoId, this._startSeconds, this._endSeconds, this._suggestedQuality, this._destroyed); // After all of the subscriptions are set up, connect the observable.\n\n      playerObs.connect();\n    }\n\n    ngAfterViewInit() {\n      this._youtubeContainer.next(this.youtubeContainer.nativeElement);\n    }\n\n    ngOnDestroy() {\n      if (this._player) {\n        this._player.destroy();\n\n        window.onYouTubeIframeAPIReady = this._existingApiReadyCallback;\n      }\n\n      this._playerChanges.complete();\n\n      this._videoId.complete();\n\n      this._height.complete();\n\n      this._width.complete();\n\n      this._startSeconds.complete();\n\n      this._endSeconds.complete();\n\n      this._suggestedQuality.complete();\n\n      this._youtubeContainer.complete();\n\n      this._playerVars.complete();\n\n      this._destroyed.next();\n\n      this._destroyed.complete();\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#playVideo */\n\n\n    playVideo() {\n      if (this._player) {\n        this._player.playVideo();\n      } else {\n        this._getPendingState().playbackState = YT.PlayerState.PLAYING;\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#pauseVideo */\n\n\n    pauseVideo() {\n      if (this._player) {\n        this._player.pauseVideo();\n      } else {\n        this._getPendingState().playbackState = YT.PlayerState.PAUSED;\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#stopVideo */\n\n\n    stopVideo() {\n      if (this._player) {\n        this._player.stopVideo();\n      } else {\n        // It seems like YouTube sets the player to CUED when it's stopped.\n        this._getPendingState().playbackState = YT.PlayerState.CUED;\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#seekTo */\n\n\n    seekTo(seconds, allowSeekAhead) {\n      if (this._player) {\n        this._player.seekTo(seconds, allowSeekAhead);\n      } else {\n        this._getPendingState().seek = {\n          seconds,\n          allowSeekAhead\n        };\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#mute */\n\n\n    mute() {\n      if (this._player) {\n        this._player.mute();\n      } else {\n        this._getPendingState().muted = true;\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#unMute */\n\n\n    unMute() {\n      if (this._player) {\n        this._player.unMute();\n      } else {\n        this._getPendingState().muted = false;\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#isMuted */\n\n\n    isMuted() {\n      if (this._player) {\n        return this._player.isMuted();\n      }\n\n      if (this._pendingPlayerState) {\n        return !!this._pendingPlayerState.muted;\n      }\n\n      return false;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#setVolume */\n\n\n    setVolume(volume) {\n      if (this._player) {\n        this._player.setVolume(volume);\n      } else {\n        this._getPendingState().volume = volume;\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVolume */\n\n\n    getVolume() {\n      if (this._player) {\n        return this._player.getVolume();\n      }\n\n      if (this._pendingPlayerState && this._pendingPlayerState.volume != null) {\n        return this._pendingPlayerState.volume;\n      }\n\n      return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate */\n\n\n    setPlaybackRate(playbackRate) {\n      if (this._player) {\n        return this._player.setPlaybackRate(playbackRate);\n      } else {\n        this._getPendingState().playbackRate = playbackRate;\n      }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlaybackRate */\n\n\n    getPlaybackRate() {\n      if (this._player) {\n        return this._player.getPlaybackRate();\n      }\n\n      if (this._pendingPlayerState && this._pendingPlayerState.playbackRate != null) {\n        return this._pendingPlayerState.playbackRate;\n      }\n\n      return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getAvailablePlaybackRates */\n\n\n    getAvailablePlaybackRates() {\n      return this._player ? this._player.getAvailablePlaybackRates() : [];\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoLoadedFraction */\n\n\n    getVideoLoadedFraction() {\n      return this._player ? this._player.getVideoLoadedFraction() : 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlayerState */\n\n\n    getPlayerState() {\n      if (!this._isBrowser || !window.YT) {\n        return undefined;\n      }\n\n      if (this._player) {\n        return this._player.getPlayerState();\n      }\n\n      if (this._pendingPlayerState && this._pendingPlayerState.playbackState != null) {\n        return this._pendingPlayerState.playbackState;\n      }\n\n      return YT.PlayerState.UNSTARTED;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getCurrentTime */\n\n\n    getCurrentTime() {\n      if (this._player) {\n        return this._player.getCurrentTime();\n      }\n\n      if (this._pendingPlayerState && this._pendingPlayerState.seek) {\n        return this._pendingPlayerState.seek.seconds;\n      }\n\n      return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlaybackQuality */\n\n\n    getPlaybackQuality() {\n      return this._player ? this._player.getPlaybackQuality() : 'default';\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getAvailableQualityLevels */\n\n\n    getAvailableQualityLevels() {\n      return this._player ? this._player.getAvailableQualityLevels() : [];\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getDuration */\n\n\n    getDuration() {\n      return this._player ? this._player.getDuration() : 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoUrl */\n\n\n    getVideoUrl() {\n      return this._player ? this._player.getVideoUrl() : '';\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoEmbedCode */\n\n\n    getVideoEmbedCode() {\n      return this._player ? this._player.getVideoEmbedCode() : '';\n    }\n    /** Gets an object that should be used to store the temporary API state. */\n\n\n    _getPendingState() {\n      if (!this._pendingPlayerState) {\n        this._pendingPlayerState = {};\n      }\n\n      return this._pendingPlayerState;\n    }\n    /** Initializes a player from a temporary state. */\n\n\n    _initializePlayer(player, state) {\n      const {\n        playbackState,\n        playbackRate,\n        volume,\n        muted,\n        seek\n      } = state;\n\n      switch (playbackState) {\n        case YT.PlayerState.PLAYING:\n          player.playVideo();\n          break;\n\n        case YT.PlayerState.PAUSED:\n          player.pauseVideo();\n          break;\n\n        case YT.PlayerState.CUED:\n          player.stopVideo();\n          break;\n      }\n\n      if (playbackRate != null) {\n        player.setPlaybackRate(playbackRate);\n      }\n\n      if (volume != null) {\n        player.setVolume(volume);\n      }\n\n      if (muted != null) {\n        muted ? player.mute() : player.unMute();\n      }\n\n      if (seek != null) {\n        player.seekTo(seek.seconds, seek.allowSeekAhead);\n      }\n    }\n    /** Gets an observable that adds an event listener to the player when a user subscribes to it. */\n\n\n    _getLazyEmitter(name) {\n      // Start with the stream of players. This way the events will be transferred\n      // over to the new player if it gets swapped out under-the-hood.\n      return this._playerChanges.pipe( // Switch to the bound event. `switchMap` ensures that the old event is removed when the\n      // player is changed. If there's no player, return an observable that never emits.\n      switchMap(player => {\n        return player ? fromEventPattern(listener => {\n          player.addEventListener(name, listener);\n        }, listener => {\n          // The API seems to throw when we try to unbind from a destroyed player and it doesn't\n          // expose whether the player has been destroyed so we have to wrap it in a try/catch to\n          // prevent the entire stream from erroring out.\n          try {\n            if (player.removeEventListener) {\n              player.removeEventListener(name, listener);\n            }\n          } catch (_a) {}\n        }) : of();\n      }), // By default we run all the API interactions outside the zone\n      // so we have to bring the events back in manually when they emit.\n      source => new Observable(observer => source.subscribe({\n        next: value => this._ngZone.run(() => observer.next(value)),\n        error: error => observer.error(error),\n        complete: () => observer.complete()\n      })), // Ensures that everything is cleared out on destroy.\n      takeUntil(this._destroyed));\n    }\n\n  }\n\n  YouTubePlayer.ɵfac = function YouTubePlayer_Factory(t) {\n    return new (t || YouTubePlayer)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(PLATFORM_ID));\n  };\n\n  YouTubePlayer.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: YouTubePlayer,\n    selectors: [[\"youtube-player\"]],\n    viewQuery: function YouTubePlayer_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.youtubeContainer = _t.first);\n      }\n    },\n    inputs: {\n      videoId: \"videoId\",\n      height: \"height\",\n      width: \"width\",\n      startSeconds: \"startSeconds\",\n      endSeconds: \"endSeconds\",\n      suggestedQuality: \"suggestedQuality\",\n      playerVars: \"playerVars\",\n      showBeforeIframeApiLoads: \"showBeforeIframeApiLoads\"\n    },\n    outputs: {\n      ready: \"ready\",\n      stateChange: \"stateChange\",\n      error: \"error\",\n      apiChange: \"apiChange\",\n      playbackQualityChange: \"playbackQualityChange\",\n      playbackRateChange: \"playbackRateChange\"\n    },\n    decls: 2,\n    vars: 0,\n    consts: [[\"youtubeContainer\", \"\"]],\n    template: function YouTubePlayer_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", null, 0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return YouTubePlayer;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Listens to changes to the given width and height and sets it on the player. */\n\n\nfunction bindSizeToPlayer(playerObs, widthObs, heightObs) {\n  return combineLatest([playerObs, widthObs, heightObs]).subscribe(([player, width, height]) => player && player.setSize(width, height));\n}\n/** Listens to changes from the suggested quality and sets it on the given player. */\n\n\nfunction bindSuggestedQualityToPlayer(playerObs, suggestedQualityObs) {\n  return combineLatest([playerObs, suggestedQualityObs]).subscribe(([player, suggestedQuality]) => player && suggestedQuality && player.setPlaybackQuality(suggestedQuality));\n}\n/**\n * Returns an observable that emits the loaded player once it's ready. Certain properties/methods\n * won't be available until the iframe finishes loading.\n * @param onAbort Callback function that will be invoked if the player loading was aborted before\n * it was able to complete. Can be used to clean up any loose references.\n */\n\n\nfunction waitUntilReady(onAbort) {\n  return mergeMap(player => {\n    if (!player) {\n      return of(undefined);\n    }\n\n    if (playerIsReady(player)) {\n      return of(player);\n    } // Since removeEventListener is not on Player when it's initialized, we can't use fromEvent.\n    // The player is not initialized fully until the ready is called.\n\n\n    return new Observable(emitter => {\n      let aborted = false;\n      let resolved = false;\n\n      const onReady = event => {\n        resolved = true;\n\n        if (!aborted) {\n          event.target.removeEventListener('onReady', onReady);\n          emitter.next(event.target);\n        }\n      };\n\n      player.addEventListener('onReady', onReady);\n      return () => {\n        aborted = true;\n\n        if (!resolved) {\n          onAbort(player);\n        }\n      };\n    }).pipe(take(1), startWith(undefined));\n  });\n}\n/** Create an observable for the player based on the given options. */\n\n\nfunction createPlayerObservable(youtubeContainer, videoIdObs, iframeApiAvailableObs, widthObs, heightObs, playerVarsObs, ngZone) {\n  const playerOptions = combineLatest([videoIdObs, playerVarsObs]).pipe(withLatestFrom(combineLatest([widthObs, heightObs])), map(([constructorOptions, sizeOptions]) => {\n    const [videoId, playerVars] = constructorOptions;\n    const [width, height] = sizeOptions;\n    return videoId ? {\n      videoId,\n      playerVars,\n      width,\n      height\n    } : undefined;\n  }));\n  return combineLatest([youtubeContainer, playerOptions, of(ngZone)]).pipe(skipUntilRememberLatest(iframeApiAvailableObs), scan(syncPlayerState, undefined), distinctUntilChanged());\n}\n/** Skips the given observable until the other observable emits true, then emit the latest. */\n\n\nfunction skipUntilRememberLatest(notifier) {\n  return pipe(combineLatest$1(notifier), skipWhile(([_, doneSkipping]) => !doneSkipping), map(([value]) => value));\n}\n/** Destroy the player if there are no options, or create the player if there are options. */\n\n\nfunction syncPlayerState(player, [container, videoOptions, ngZone]) {\n  if (player && videoOptions && player.playerVars !== videoOptions.playerVars) {\n    // The player needs to be recreated if the playerVars are different.\n    player.destroy();\n  } else if (!videoOptions) {\n    if (player) {\n      // Destroy the player if the videoId was removed.\n      player.destroy();\n    }\n\n    return;\n  } else if (player) {\n    return player;\n  } // Important! We need to create the Player object outside of the `NgZone`, because it kicks\n  // off a 250ms setInterval which will continually trigger change detection if we don't.\n\n\n  const newPlayer = ngZone.runOutsideAngular(() => new YT.Player(container, videoOptions));\n  newPlayer.videoId = videoOptions.videoId;\n  newPlayer.playerVars = videoOptions.playerVars;\n  return newPlayer;\n}\n/**\n * Call cueVideoById if the videoId changes, or when start or end seconds change. cueVideoById will\n * change the loaded video id to the given videoId, and set the start and end times to the given\n * start/end seconds.\n */\n\n\nfunction bindCueVideoCall(playerObs, videoIdObs, startSecondsObs, endSecondsObs, suggestedQualityObs, destroyed) {\n  const cueOptionsObs = combineLatest([startSecondsObs, endSecondsObs]).pipe(map(([startSeconds, endSeconds]) => ({\n    startSeconds,\n    endSeconds\n  }))); // Only respond to changes in cue options if the player is not running.\n\n  const filteredCueOptions = cueOptionsObs.pipe(filterOnOther(playerObs, player => !!player && !hasPlayerStarted(player))); // If the video id changed, there's no reason to run 'cue' unless the player\n  // was initialized with a different video id.\n\n  const changedVideoId = videoIdObs.pipe(filterOnOther(playerObs, (player, videoId) => !!player && player.videoId !== videoId)); // If the player changed, there's no reason to run 'cue' unless there are cue options.\n\n  const changedPlayer = playerObs.pipe(filterOnOther(combineLatest([videoIdObs, cueOptionsObs]), ([videoId, cueOptions], player) => !!player && (videoId != player.videoId || !!cueOptions.startSeconds || !!cueOptions.endSeconds)));\n  merge(changedPlayer, changedVideoId, filteredCueOptions).pipe(withLatestFrom(combineLatest([playerObs, videoIdObs, cueOptionsObs, suggestedQualityObs])), map(([_, values]) => values), takeUntil(destroyed)).subscribe(([player, videoId, cueOptions, suggestedQuality]) => {\n    if (!videoId || !player) {\n      return;\n    }\n\n    player.videoId = videoId;\n    player.cueVideoById(Object.assign({\n      videoId,\n      suggestedQuality\n    }, cueOptions));\n  });\n}\n\nfunction hasPlayerStarted(player) {\n  const state = player.getPlayerState();\n  return state !== YT.PlayerState.UNSTARTED && state !== YT.PlayerState.CUED;\n}\n\nfunction playerIsReady(player) {\n  return 'getPlayerStatus' in player;\n}\n/** Combines the two observables temporarily for the filter function. */\n\n\nfunction filterOnOther(otherObs, filterFn) {\n  return pipe(withLatestFrom(otherObs), filter(([value, other]) => filterFn(other, value)), map(([value]) => value));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst COMPONENTS = [YouTubePlayer];\nlet YouTubePlayerModule = /*#__PURE__*/(() => {\n  class YouTubePlayerModule {}\n\n  YouTubePlayerModule.ɵfac = function YouTubePlayerModule_Factory(t) {\n    return new (t || YouTubePlayerModule)();\n  };\n\n  YouTubePlayerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: YouTubePlayerModule\n  });\n  YouTubePlayerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return YouTubePlayerModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { YouTubePlayer, YouTubePlayerModule }; //# sourceMappingURL=youtube-player.mjs.map","map":null,"metadata":{},"sourceType":"module"}